{"ast":null,"code":"import _slicedToArray from \"/Users/gimga-eun/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"/Users/gimga-eun/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport * as React from 'react';\nimport { useContext, useRef, useState, useEffect } from 'react';\nimport { useMemoOne, useOnce, raf } from '@react-spring/shared';\nimport { Controller, a, config } from '@react-spring/web';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar _excluded = [\"horizontal\", \"factor\", \"offset\", \"speed\", \"sticky\"],\n    _excluded2 = [\"pages\", \"innerStyle\", \"config\", \"enabled\", \"horizontal\", \"children\"];\nvar ParentContext = React.createContext(null);\n\nfunction getScrollType(horizontal) {\n  return horizontal ? 'scrollLeft' : 'scrollTop';\n}\n\nfunction mapChildrenRecursive(children, callback) {\n  var isReactFragment = function isReactFragment(node) {\n    if (node.type) {\n      return node.type === React.Fragment;\n    }\n\n    return node === React.Fragment;\n  };\n\n  return React.Children.map(children, function (child) {\n    return isReactFragment(child) ? mapChildrenRecursive(child.props.children, callback) : callback(child);\n  });\n}\n\nvar START_TRANSLATE_3D = 'translate3d(0px,0px,0px)';\nvar START_TRANSLATE = 'translate(0px,0px)';\nvar ParallaxLayer = React.memo(React.forwardRef(function (_ref, ref) {\n  var _extends2;\n\n  var horizontal = _ref.horizontal,\n      _ref$factor = _ref.factor,\n      factor = _ref$factor === void 0 ? 1 : _ref$factor,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? 0 : _ref$offset,\n      _ref$speed = _ref.speed,\n      speed = _ref$speed === void 0 ? 0 : _ref$speed,\n      sticky = _ref.sticky,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  var parent = useContext(ParentContext);\n  var ctrl = useMemoOne(function () {\n    var translate;\n\n    if (sticky) {\n      var start = sticky.start || 0;\n      translate = start * parent.space;\n    } else {\n      var targetScroll = Math.floor(offset) * parent.space;\n      var distance = parent.space * offset + targetScroll * speed;\n      translate = -(parent.current * speed) + distance;\n    }\n\n    return new Controller({\n      space: sticky ? parent.space : parent.space * factor,\n      translate: translate\n    });\n  }, []);\n  var layer = useMemoOne(function () {\n    return {\n      horizontal: horizontal === undefined || sticky ? parent.horizontal : horizontal,\n      sticky: undefined,\n      isSticky: false,\n      setPosition: function setPosition(height, scrollTop) {\n        var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        if (sticky) {\n          setSticky(height, scrollTop);\n        } else {\n          var targetScroll = Math.floor(offset) * height;\n          var distance = height * offset + targetScroll * speed;\n          ctrl.start({\n            translate: -(scrollTop * speed) + distance,\n            config: parent.config,\n            immediate: immediate\n          });\n        }\n      },\n      setHeight: function setHeight(height) {\n        var immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        ctrl.start({\n          space: sticky ? height : height * factor,\n          config: parent.config,\n          immediate: immediate\n        });\n      }\n    };\n  }, []);\n  useOnce(function () {\n    if (sticky) {\n      var start = sticky.start || 0;\n      var end = sticky.end || start + 1;\n      layer.sticky = {\n        start: start,\n        end: end\n      };\n    }\n  });\n  React.useImperativeHandle(ref, function () {\n    return layer;\n  });\n  var layerRef = useRef();\n\n  var setSticky = function setSticky(height, scrollTop) {\n    var start = layer.sticky.start * height;\n    var end = layer.sticky.end * height;\n    var isSticky = scrollTop >= start && scrollTop <= end;\n    if (isSticky === layer.isSticky) return;\n    layer.isSticky = isSticky;\n    var ref = layerRef.current;\n    ref.style.position = isSticky ? 'sticky' : 'absolute';\n    ctrl.set({\n      translate: isSticky ? 0 : scrollTop < start ? start : end\n    });\n  };\n\n  useOnce(function () {\n    if (parent) {\n      parent.layers.add(layer);\n      parent.update();\n      return function () {\n        parent.layers.delete(layer);\n        parent.update();\n      };\n    }\n  });\n  var translate3d = ctrl.springs.translate.to(layer.horizontal ? function (x) {\n    return \"translate3d(\".concat(x, \"px,0,0)\");\n  } : function (y) {\n    return \"translate3d(0,\".concat(y, \"px,0)\");\n  });\n  return React.createElement(a.div, _extends({}, rest, {\n    ref: layerRef,\n    style: _extends((_extends2 = {\n      position: 'absolute',\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      backgroundSize: 'auto',\n      backgroundRepeat: 'no-repeat',\n      willChange: 'transform'\n    }, _defineProperty(_extends2, layer.horizontal ? 'height' : 'width', '100%'), _defineProperty(_extends2, layer.horizontal ? 'width' : 'height', ctrl.springs.space), _defineProperty(_extends2, \"WebkitTransform\", translate3d), _defineProperty(_extends2, \"msTransform\", translate3d), _defineProperty(_extends2, \"transform\", translate3d), _extends2), rest.style)\n  }));\n}));\nvar Parallax = React.memo(React.forwardRef(function (props, ref) {\n  var _extends3;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      ready = _useState2[0],\n      setReady = _useState2[1];\n\n  var pages = props.pages,\n      _props$config = props.config,\n      config$1 = _props$config === void 0 ? config.slow : _props$config,\n      _props$enabled = props.enabled,\n      enabled = _props$enabled === void 0 ? true : _props$enabled,\n      _props$horizontal = props.horizontal,\n      horizontal = _props$horizontal === void 0 ? false : _props$horizontal,\n      children = props.children,\n      rest = _objectWithoutPropertiesLoose(props, _excluded2);\n\n  var containerRef = useRef();\n  var contentRef = useRef();\n  var state = useMemoOne(function () {\n    return {\n      config: config$1,\n      horizontal: horizontal,\n      busy: false,\n      space: 0,\n      current: 0,\n      offset: 0,\n      controller: new Controller({\n        scroll: 0\n      }),\n      layers: new Set(),\n      container: containerRef,\n      content: contentRef,\n      update: function update() {\n        return _update();\n      },\n      scrollTo: function scrollTo(offset) {\n        return _scrollTo(offset);\n      },\n      stop: function stop() {\n        return state.controller.stop();\n      }\n    };\n  }, []);\n  useEffect(function () {\n    state.config = config$1;\n  }, [config$1]);\n  React.useImperativeHandle(ref, function () {\n    return state;\n  });\n\n  var _update = function _update() {\n    var container = containerRef.current;\n    if (!container) return;\n    var spaceProp = horizontal ? 'clientWidth' : 'clientHeight';\n    state.space = container[spaceProp];\n    var scrollType = getScrollType(horizontal);\n\n    if (enabled) {\n      state.current = container[scrollType];\n    } else {\n      container[scrollType] = state.current = state.offset * state.space;\n    }\n\n    var content = contentRef.current;\n\n    if (content) {\n      var sizeProp = horizontal ? 'width' : 'height';\n      content.style[sizeProp] = \"\".concat(state.space * pages, \"px\");\n    }\n\n    state.layers.forEach(function (layer) {\n      layer.setHeight(state.space, true);\n      layer.setPosition(state.space, state.current, true);\n    });\n  };\n\n  var _scrollTo = function _scrollTo(offset) {\n    var container = containerRef.current;\n    var scrollType = getScrollType(horizontal);\n    state.offset = offset;\n    state.controller.set({\n      scroll: state.current\n    });\n    state.controller.stop().start({\n      scroll: offset * state.space,\n      config: config$1,\n      onChange: function onChange(_ref2) {\n        var scroll = _ref2.value.scroll;\n        container[scrollType] = scroll;\n      }\n    });\n  };\n\n  var onScroll = function onScroll(event) {\n    if (!state.busy) {\n      state.busy = true;\n      state.current = event.target[getScrollType(horizontal)];\n      raf.onStart(function () {\n        state.layers.forEach(function (layer) {\n          return layer.setPosition(state.space, state.current);\n        });\n        state.busy = false;\n      });\n    }\n  };\n\n  useEffect(function () {\n    return state.update();\n  });\n  useOnce(function () {\n    setReady(true);\n\n    var onResize = function onResize() {\n      var update = function update() {\n        return state.update();\n      };\n\n      raf.onFrame(update);\n      setTimeout(update, 150);\n    };\n\n    window.addEventListener('resize', onResize, false);\n    return function () {\n      return window.removeEventListener('resize', onResize, false);\n    };\n  });\n  var overflow = enabled ? {\n    overflowY: horizontal ? 'hidden' : 'scroll',\n    overflowX: horizontal ? 'scroll' : 'hidden'\n  } : {\n    overflowY: 'hidden',\n    overflowX: 'hidden'\n  };\n  return React.createElement(a.div, _extends({}, rest, {\n    ref: containerRef,\n    onScroll: onScroll,\n    onWheel: enabled ? state.stop : undefined,\n    onTouchStart: enabled ? state.stop : undefined,\n    style: _extends({\n      position: 'absolute',\n      width: '100%',\n      height: '100%'\n    }, overflow, {\n      WebkitOverflowScrolling: 'touch',\n      WebkitTransform: START_TRANSLATE,\n      msTransform: START_TRANSLATE,\n      transform: START_TRANSLATE_3D\n    }, rest.style)\n  }), ready && React.createElement(React.Fragment, null, React.createElement(a.div, {\n    ref: contentRef,\n    style: _extends((_extends3 = {\n      overflow: 'hidden',\n      position: 'absolute'\n    }, _defineProperty(_extends3, horizontal ? 'height' : 'width', '100%'), _defineProperty(_extends3, horizontal ? 'width' : 'height', state.space * pages), _defineProperty(_extends3, \"WebkitTransform\", START_TRANSLATE), _defineProperty(_extends3, \"msTransform\", START_TRANSLATE), _defineProperty(_extends3, \"transform\", START_TRANSLATE_3D), _extends3), props.innerStyle)\n  }, React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, function (child) {\n    return !child.props.sticky && child;\n  }))), React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, function (child) {\n    return child.props.sticky && child;\n  }))));\n}));\nexport { Parallax, ParallaxLayer };","map":null,"metadata":{},"sourceType":"module"}